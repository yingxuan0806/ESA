which.max(c(win.1, TRUE)) < which.max(c(win.0, TRUE))
})
mean(sim)
n <- 4
m <- 0
sim <- replicate(n.sim, {
x <- sample(1:0, 3*(m+n), prob=c(p, 1-p), replace = TRUE)
points.1 <- cumsum(x)
points.0 <- cumsum(1-x)
win.1 <- points.1 >= m & points.0 <= points.1 - margin
win.0 <- points.0 >= n & points.1 <= points.0 - margin
which.max(c(win.1, TRUE)) < which.max(c(win.0, TRUE))
})
mean(sim)
n <- 4
m <- 1
sim <- replicate(n.sim, {
x <- sample(1:0, 3*(m+n), prob=c(p, 1-p), replace = TRUE)
points.1 <- cumsum(x)
points.0 <- cumsum(1-x)
win.1 <- points.1 >= m & points.0 <= points.1 - margin
win.0 <- points.0 >= n & points.1 <= points.0 - margin
which.max(c(win.1, TRUE)) < which.max(c(win.0, TRUE))
})
mean(sim)
n <- 4
m <- 2
sim <- replicate(n.sim, {
x <- sample(1:0, 3*(m+n), prob=c(p, 1-p), replace = TRUE)
points.1 <- cumsum(x)
points.0 <- cumsum(1-x)
win.1 <- points.1 >= m & points.0 <= points.1 - margin
win.0 <- points.0 >= n & points.1 <= points.0 - margin
which.max(c(win.1, TRUE)) < which.max(c(win.0, TRUE))
})
mean(sim)
n <- 5
m <- 0
sim <- replicate(n.sim, {
x <- sample(1:0, 3*(m+n), prob=c(p, 1-p), replace = TRUE)
points.1 <- cumsum(x)
points.0 <- cumsum(1-x)
win.1 <- points.1 >= m & points.0 <= points.1 - margin
win.0 <- points.0 >= n & points.1 <= points.0 - margin
which.max(c(win.1, TRUE)) < which.max(c(win.0, TRUE))
})
mean(sim)
n <- 5
m <- 1
sim <- replicate(n.sim, {
x <- sample(1:0, 3*(m+n), prob=c(p, 1-p), replace = TRUE)
points.1 <- cumsum(x)
points.0 <- cumsum(1-x)
win.1 <- points.1 >= m & points.0 <= points.1 - margin
win.0 <- points.0 >= n & points.1 <= points.0 - margin
which.max(c(win.1, TRUE)) < which.max(c(win.0, TRUE))
})
mean(sim)
n <- 5
m <- 2
sim <- replicate(n.sim, {
x <- sample(1:0, 3*(m+n), prob=c(p, 1-p), replace = TRUE)
points.1 <- cumsum(x)
points.0 <- cumsum(1-x)
win.1 <- points.1 >= m & points.0 <= points.1 - margin
win.0 <- points.0 >= n & points.1 <= points.0 - margin
which.max(c(win.1, TRUE)) < which.max(c(win.0, TRUE))
})
## Including libraries
remove(list=objects())
## Including libraries
remove(list=objects())
library(grid)
## Including libraries
##remove(list=objects())
library(grid)
install.packages("plotrix")
## Including libraries
remove(list=objects())
library(grid)
library(lattice)
library(plotrix)
dat1<-rnorm(2000)
qqnorm(dat1);
qqline(dat1,col=2)
dat2<-rexp(2000)
qqnorm(dat2);
qqline(dat2,col=2)
dat3<-rpois(2000,200)
qqnorm(dat3);
qqline(dat3,col=2)
hist(dat3,breaks=100)
dat4<-rt(1000,2)
#2*((runif(1000)>0.5)-0.5)*(runif(1000))^(-0.5)
qqnorm(dat4,ylim=c(-10,10));
qqline(dat4,col=2)
library(plotrix)
datavalues <- c(6.10, 6.74, 6.22, 5.65, 6.38, 6.70, 7.00, 6.43, 7.00, 6.70, 6.70, 5.94, 6.28, 6.34, 6.62, 6.55, 2.92, 6.10, 6.20, 6.70, 7.00, 6.85, 6.31, 6.26, 6.36, 6.28, 6.38, 6.70, 6.62, 7.00, 6.45, 6.31, 2.86, 6.31, 6.09, 6.17, 6.64, 6.45, 7.00, 6.18, 6.58, 5.38, 6.34, 7.00, 5.70, 6.65, 6.56, 6.00, 6.70, 6.45)
summary(datavalues)
mean(datavalues, trim=0.1)
sd(datavalues)
boxplot(datavalues)
qqnorm(datavalues)
qqline(datavalues, col=2)
library(grid)
library(lattice)
library(plotrix)
data6 <- c(20, 18, 25, 25, 0, 20, 60, 0, 20, 10, 10, 20, 40, 26, 40, 12, 16, 16, 36, 38, 21, 15, 13, 10, 10)
summary(data6)
sd(data6)
qqnorm(data6)
qqline(data6, col=2)
install.packages("IIS")
show(pines_1997)
data(pines_1997)
help(data)
data(package="IIS")
data("pines_1997")
data(pines_1997)
data("gender_roles")
install.packages(IIS)
library(IIS)
install.packages("IIS")
data("pines_1997")
install.packages(c("asbio", "bayesplot", "BDgraph", "BH", "bit", "blavaan", "blob", "boot", "broom", "callr", "caTools", "checkmate", "cli", "curl", "data.table", "DBI", "dendextend", "DescTools", "deSolve", "digest", "dplyr", "DT", "emmeans", "fansi", "forcats", "foreach", "foreign", "future", "future.apply", "ggm", "ggplot2", "ggridges", "globals", "gplots", "Hmisc", "hms", "htmlTable", "huge", "igraph", "jpeg", "jsonlite", "KernSmooth", "knitr", "lattice", "latticeExtra", "lifecycle", "listenv", "lmerTest", "loo", "MASS", "Matrix", "mcmc", "MCMCpack", "mgcv", "mime", "mnormt", "modeltools", "MuMIn", "mvtnorm", "nlme", "nloptr", "nnet", "pillar", "plyr", "prettyunits", "processx", "ps", "psych", "psycho", "purrr", "qgraph", "quantreg", "R6", "Rcpp", "RcppEigen", "rlang", "rmarkdown", "rsconnect", "RSQLite", "rstan", "rstanarm", "rstudioapi", "scales", "shinyjs", "SparseM", "StanHeaders", "stringi", "survival", "threejs", "tidyr", "tidyselect", "tinytex", "TSP", "vctrs", "xfun", "xts", "yaml", "zoo"))
install.packages(c("asbio", "bayesplot", "BDgraph", "BH", "bit", "blavaan", "blob", "boot", "broom", "callr", "caTools", "checkmate", "cli", "curl", "data.table", "DBI", "dendextend", "DescTools", "deSolve", "digest", "dplyr", "DT", "emmeans", "fansi", "forcats", "foreach", "foreign", "future", "future.apply", "ggm", "ggplot2", "ggridges", "globals", "gplots", "Hmisc", "hms", "htmlTable", "huge", "igraph", "jpeg", "jsonlite", "KernSmooth", "knitr", "lattice", "latticeExtra", "lifecycle", "listenv", "lmerTest", "loo", "MASS", "Matrix", "mcmc", "MCMCpack", "mgcv", "mime", "mnormt", "modeltools", "MuMIn", "mvtnorm", "nlme", "nloptr", "nnet", "pillar", "plyr", "prettyunits", "processx", "ps", "psych", "psycho", "purrr", "qgraph", "quantreg", "R6", "Rcpp", "RcppEigen", "rlang", "rmarkdown", "rsconnect", "RSQLite", "rstan", "rstanarm", "rstudioapi", "scales", "shinyjs", "SparseM", "StanHeaders", "stringi", "survival", "threejs", "tidyr", "tidyselect", "tinytex", "TSP", "vctrs", "xfun", "xts", "yaml", "zoo"))
install.packages(c("asbio", "bayesplot", "BDgraph", "BH", "bit", "blavaan", "blob", "boot", "broom", "callr", "caTools", "checkmate", "cli", "curl", "data.table", "DBI", "dendextend", "DescTools", "deSolve", "digest", "dplyr", "DT", "emmeans", "fansi", "forcats", "foreach", "foreign", "future", "future.apply", "ggm", "ggplot2", "ggridges", "globals", "gplots", "Hmisc", "hms", "htmlTable", "huge", "igraph", "jpeg", "jsonlite", "KernSmooth", "knitr", "lattice", "latticeExtra", "lifecycle", "listenv", "lmerTest", "loo", "MASS", "Matrix", "mcmc", "MCMCpack", "mgcv", "mime", "mnormt", "modeltools", "MuMIn", "mvtnorm", "nlme", "nloptr", "nnet", "pillar", "plyr", "prettyunits", "processx", "ps", "psych", "psycho", "purrr", "qgraph", "quantreg", "R6", "Rcpp", "RcppEigen", "rlang", "rmarkdown", "rsconnect", "RSQLite", "rstan", "rstanarm", "rstudioapi", "scales", "shinyjs", "SparseM", "StanHeaders", "stringi", "survival", "threejs", "tidyr", "tidyselect", "tinytex", "TSP", "vctrs", "xfun", "xts", "yaml", "zoo"))
install.packages(c("asbio", "bayesplot", "BDgraph", "BH", "bit", "blavaan", "blob", "boot", "broom", "callr", "caTools", "checkmate", "cli", "curl", "data.table", "DBI", "dendextend", "DescTools", "deSolve", "digest", "dplyr", "DT", "emmeans", "fansi", "forcats", "foreach", "foreign", "future", "future.apply", "ggm", "ggplot2", "ggridges", "globals", "gplots", "Hmisc", "hms", "htmlTable", "huge", "igraph", "jpeg", "jsonlite", "KernSmooth", "knitr", "lattice", "latticeExtra", "lifecycle", "listenv", "lmerTest", "loo", "MASS", "Matrix", "mcmc", "MCMCpack", "mgcv", "mime", "mnormt", "modeltools", "MuMIn", "mvtnorm", "nlme", "nloptr", "nnet", "pillar", "plyr", "prettyunits", "processx", "ps", "psych", "psycho", "purrr", "qgraph", "quantreg", "R6", "Rcpp", "RcppEigen", "rlang", "rmarkdown", "rsconnect", "RSQLite", "rstan", "rstanarm", "rstudioapi", "scales", "shinyjs", "SparseM", "StanHeaders", "stringi", "survival", "threejs", "tidyr", "tidyselect", "tinytex", "TSP", "vctrs", "xfun", "xts", "yaml", "zoo"))
install.packages(c("asbio", "bayesplot", "BDgraph", "BH", "bit", "blavaan", "blob", "boot", "broom", "callr", "caTools", "checkmate", "cli", "curl", "data.table", "DBI", "dendextend", "DescTools", "deSolve", "digest", "dplyr", "DT", "emmeans", "fansi", "forcats", "foreach", "foreign", "future", "future.apply", "ggm", "ggplot2", "ggridges", "globals", "gplots", "Hmisc", "hms", "htmlTable", "huge", "igraph", "jpeg", "jsonlite", "KernSmooth", "knitr", "lattice", "latticeExtra", "lifecycle", "listenv", "lmerTest", "loo", "MASS", "Matrix", "mcmc", "MCMCpack", "mgcv", "mime", "mnormt", "modeltools", "MuMIn", "mvtnorm", "nlme", "nloptr", "nnet", "pillar", "plyr", "prettyunits", "processx", "ps", "psych", "psycho", "purrr", "qgraph", "quantreg", "R6", "Rcpp", "RcppEigen", "rlang", "rmarkdown", "rsconnect", "RSQLite", "rstan", "rstanarm", "rstudioapi", "scales", "shinyjs", "SparseM", "StanHeaders", "stringi", "survival", "threejs", "tidyr", "tidyselect", "tinytex", "TSP", "vctrs", "xfun", "xts", "yaml", "zoo"))
help(package)
help(data)
installed.packages()
install.packages(IIT-package)
install.packages(IIS-package)
install.packages("IIS-package")
install.packages("IIS")
installed.packages()
data("IIS")
data("pines_1997")
library(IIS)
install.packages("Stat2Data")
library(Stat2Data)
data(pines)
data("pines")
data(Pines)
summary(Pines)
install.packages(IIS-package)
load("/Users/yingxuan/Downloads/IIS/data/pines_1997.rda")
View(pines_1997)
install.packages("~/Downloads/IIS_1.0.tar.gz", repos = NULL, type = "source")
a <- 1:10/5
print(a)
a = 1:(10/5)
print (a)
for (i in 1:5) {b <- 2^i; print(b)}
install.packages("shiny")
1-pchisq(2(7-1), 7)
1-pchisq(2*(7-1), 7)
1-pchisq(2*(7-1), 6)
1-pchisq(2*(8-1), 6)
1-pchisq(2*(8-1), 7)
1-pchisq(2*(17-1), 16)
1-pchisq(2*20, 20)
qt(0.95, df=99)
qt(0.95, df=100)
qt(0.9725, df=99)
qt(0.9725, df=100)
qt(0.025, df=99)
qt(p=(1-0.025), df=99)
qt(p=0.05, df=99)
qt(p=(1-0.05), df=99)
qt(p=(1-0.025), df=99)
qt(p=(1-0.025), df=9)
qchisq(p=0.05, 99)
qchisq(p=0.95, df=99)
qchisq(p=0.95, df=99)
qnorm(0.95)
qnorm(0.975)
qt(p=0.95, df=538)
qt(p=0.975, df=538)
qt(p=0.95, df=539)
qnorm(0.95)
remove(list = ls())
qqline(data, col=2)
library(grid)
library(lattice)
library(plotrix)
data <- c(24.00, 28.00, 27.75, 27.00, 24.25, 23.50, 26.25, 24.00, 25.00, 30.00,23.25, 26.25, 21.50, 26.00, 28.00, 24.50, 22.50, 28.25, 21.25, 19.75)
qqnorm(data)
qqline(data, col=2)
mean(data)
var(data)
qt(p=0.0975, df=19)
qt(p=0.975, df=19)
qt(p=0.975, df=99)
dataX <- c(12.0129, 12.0072, 12.0064, 12.0054, 12.0016,11.9853, 11.9949, 11.9985, 12.0077, 12.0061)
dataY <- c(12.0318, 12.0246, 12.0069, 12.0006, 12.0075)
mean(dataX)
mean(dataY)
var(dataX)
var(dataY)
qt(p=0.975, df=23)
qt(p=0.95, df=23)
qt(p=0.975, df=13)
qt(p=0.975, df=4)
qt(p=0.975, df=4.48)
qt(p=0.975, df=5.48)
qt(p=0.975, df=5)
qf(p=0.95, df1 = 8, df2= 8)
## Including libraries
remove(list=objects())
## Including libraries
remove(list=objects())
####### Lecture 2-2
## Facebook friends
facfr<-c(108, 103, 352, 121, 93, 53, 40, 53, 22, 116, 94)
facor<-facfr[order(facfr,decreasing=F)]
mean(facor)
median(facor)
facornew<-facor[-11]
mean(facornew)
median(facornew)
summary(facor)
### Morley data set
speed<-morley[,3]
mean(speed)
sd(speed)
summary(speed)
boxplot(speed)
hist(speed)
hist(speed, breaks=20)
### qq plot
qqnorm(speed)
qqline(speed,col=2)
dat1<-rnorm(2000)
qqnorm(dat1);
qqline(dat1,col=2)
dat2<-rexp(200)
qqnorm(dat2);
qqline(dat2,col=2)
dat3<-rpois(2000,200)
qqnorm(dat3);
qqline(dat3,col=2)
dat4<-2*((runif(1000)>0.5)-0.5)*(runif(1000))^(-0.5)
qqnorm(dat4,ylim=c(-10,10));
qqline(dat4,col=2)
### scatter plot: 31 Black cherry trees. girth (diameter), height,  volume
plot(trees[,1],trees[,2])
splom(trees)
### 5 Orange trees circumference at age
plot(Orange[,2],Orange[,3])
xyplot(circumference~age,Orange,groups= Tree,cex=1,pch=c(1,2,3,4,5))
### Anscombe look for help(anscombe)
summary(anscombe)
boxplot(anscombe)
##-- now some "magic" to do the 4 regressions in a loop:
ff <- y ~ x
mods <- setNames(as.list(1:4), paste0("lm", 1:4))
for(i in 1:4) {
ff[2:3] <- lapply(paste0(c("y","x"), i), as.name)
## or   ff[[2]] <- as.name(paste0("y", i))
##      ff[[3]] <- as.name(paste0("x", i))
mods[[i]] <- lmi <- lm(ff, data = anscombe)
print(anova(lmi))
}
## See how close they are (numerically!)
sapply(mods, coef)
lapply(mods, function(fm) coef(summary(fm)))
## Now, do what you should have done in the first place: PLOTS
op <- par(mfrow = c(2, 2), mar = 0.1+c(4,4,1,1), oma =  c(0, 0, 2, 0))
for(i in 1:4) {
ff[2:3] <- lapply(paste0(c("y","x"), i), as.name)
plot(ff, data = anscombe, col = "red", pch = 21, bg = "orange", cex = 1.2,
xlim = c(3, 19), ylim = c(3, 13))
abline(mods[[i]], col = "blue")
}
mtext("Anscombe's 4 Regression data sets", outer = TRUE, cex = 1.5)
par(op)
setwd("~/Documents/SUTD/Term 5/ESA/Week 9/Lecture 14")
# Remove all variables from the R environment to create a fresh start
rm(list=ls())
# Set the working folder -- FILL IN THE LINE BELOW
# setwd("...")
setwd("~/Documents/SUTD/Term 5/ESA/Week 9/Lecture 14")
# Packages we are going to use in this session: ggplot2, rgl (3D scatter plots),
# GGally (Parallel coordinate plots), fmsb (radar charts)
if(!require(ggplot2)){
install.packages("ggplot2")
library(ggplot2)
}
if(!require(rgl)){
install.packages("rgl")
library(rgl)
}
if(!require(GGally)){
install.packages("GGally")
library(GGally)
}
if(!require(fmsb)){
install.packages("fmsb")
library(fmsb)
}
# Import data from EngineDesign.csv
mydata <- read.csv(file="EngineDesign.csv")
# Visualize the data with a scatter plot (Horsepower vs. Cost) -- FILL IN THE LINE BELOW
a_plot1 <- ggplot(data=mydata, mapping = aes(x=Horsepower, y=Cost))  +
geom_point() +
labs(title = "Activity 1a Plot 1: Horsepower vs Cost", x = "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot1
# First, we use the source() function to load ParetoSorting.R
source("ParetoSorting.R")
# Let's double-check the input (output) required (returned) by the function ParetoSorting.R
ParetoSorting
# Prepare the input in the right format (the function requires the objectives to be maximized)
input <- matrix(c(mydata$Horsepower,mydata$Cost*(-1)),nrow=43,ncol=2)
# Run the function -- FILL IN THE LINE BELOW
result <- ParetoSorting(input)
result
# dominated count
dominated_count <- length(which(result == 1))
dominated_count
# not dominated count
notdominated_count <- length(which(result == 0))
notdominated_count
# function to create list stating string "dominated" or "pareto-efficient"
d_function <- function(list_input) {
result_list <- c()
for (i in 1:length(list_input)) {
if (list_input[i] == 1) {
name <- "Dominated"
} else {
name <- "Non-dominated"
}
result_list <- c(result_list, name)
}
return(result_list)
}
domination_list <- d_function(result)
domination_list
mydata$Dominance <- domination_list
# Then, we give a different colour to the points depending on the value in the column "Dominance"
a_plot2 <- ggplot(data=mydata, mapping = aes(x=Horsepower, y=Cost)) +
geom_point(aes(color=Dominance)) +
labs(title = "Activity 1a Plot 2: Horsepower vs Cost", x = "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot2
# How to visualize the third objective?
#
# We can represent the third objective (Fuel-efficiency) with a size or color. -- FILL IN THE LINES BELOW
# fuel efficiency by size
a_plot3 <- ggplot(data = mydata,
mapping = aes(x = Horsepower, y = Cost, size = Fuel.efficiency)) +
geom_point() + # Note that we removed "size = 3"
coord_cartesian(xlim=c(0.2,0.8), ylim=c(0,0.2)) +
labs(title = "Activity 1a Plot 3: Horsepower vs Cost", x= "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot3
# fuel efficiency by colour
a_plot4 <- ggplot(data = mydata,
mapping = aes(x = Horsepower, y = Cost, colour = Fuel.efficiency)) +
geom_point(size = 3) +
coord_cartesian(xlim=c(0.2,0.8), ylim=c(0,0.2)) +
labs(title = "Activity 1a Plot 4: Horsepower vs Cost", x= "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot4
#
# We could also use a 3D plot, for which we need the rgl package
a_plot5 <- plot3d(mydata$Horsepower, mydata$Cost, mydata$Fuel.efficiency, type="s",
size=1, lit=TRUE, main = "Horsepower Vs Cost Vs Fuel-efficiency",sub="3-D Plot")
# Now, we can determine which solutions are Pareto-efficient. First, we use the source() function to load ParetoSorting.R
source("ParetoSorting_adv.R")
# Let's double-check the input (output) required (returned) by the function ParetoSorting.R
ParetoSorting_adv
setwd("~/Documents/SUTD/Term 5/ESA/Week 9")
# Remove all variables from the R environment to create a fresh start
rm(list=ls())
temp <- (argument1[j,k] > argument1[i,k])
# Packages we are going to use in this session: ggplot2, rgl (3D scatter plots),
# GGally (Parallel coordinate plots), fmsb (radar charts)
if(!require(ggplot2)){
install.packages("ggplot2")
library(ggplot2)
}
if(!require(rgl)){
install.packages("rgl")
library(rgl)
}
if(!require(GGally)){
install.packages("GGally")
library(GGally)
}
if(!require(fmsb)){
install.packages("fmsb")
library(fmsb)
}
# Import data from EngineDesign.csv
mydata <- read.csv(file="EngineDesign.csv")
# Visualize the data with a scatter plot (Horsepower vs. Cost) -- FILL IN THE LINE BELOW
a_plot1 <- ggplot(data=mydata, mapping = aes(x=Horsepower, y=Cost))  +
geom_point() +
labs(title = "Activity 1a Plot 1: Horsepower vs Cost", x = "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot1
# First, we use the source() function to load ParetoSorting.R
source("ParetoSorting.R")
# Let's double-check the input (output) required (returned) by the function ParetoSorting.R
ParetoSorting
# Prepare the input in the right format (the function requires the objectives to be maximized)
input <- matrix(c(mydata$Horsepower,mydata$Cost*(-1)),nrow=43,ncol=2)
# Run the function -- FILL IN THE LINE BELOW
result <- ParetoSorting(input)
result
# Packages we are going to use in this session: ggplot2, rgl (3D scatter plots),
# GGally (Parallel coordinate plots), fmsb (radar charts)
if(!require(ggplot2)){
install.packages("ggplot2")
library(ggplot2)
}
if(!require(rgl)){
install.packages("rgl")
library(rgl)
}
if(!require(GGally)){
install.packages("GGally")
library(GGally)
}
if(!require(fmsb)){
install.packages("fmsb")
library(fmsb)
}
# Import data from EngineDesign.csv
mydata <- read.csv(file="EngineDesign.csv")
# Visualize the data with a scatter plot (Horsepower vs. Cost) -- FILL IN THE LINE BELOW
a_plot1 <- ggplot(data=mydata, mapping = aes(x=Horsepower, y=Cost))  +
geom_point() +
labs(title = "Activity 1a Plot 1: Horsepower vs Cost", x = "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot1
# First, we use the source() function to load ParetoSorting.R
source("ParetoSorting.R")
# Let's double-check the input (output) required (returned) by the function ParetoSorting.R
ParetoSorting
# Prepare the input in the right format (the function requires the objectives to be maximized)
input <- matrix(c(mydata$Horsepower,mydata$Cost*(-1)),nrow=43,ncol=2)
# Run the function -- FILL IN THE LINE BELOW
result <- ParetoSorting(input)
result
# First, we use the source() function to load ParetoSorting.R
source("ParetoSorting.R")
# Let's double-check the input (output) required (returned) by the function ParetoSorting.R
ParetoSorting
# Prepare the input in the right format (the function requires the objectives to be maximized)
input <- matrix(c(mydata$Horsepower,mydata$Cost*(-1)),nrow=43,ncol=2)
# Run the function -- FILL IN THE LINE BELOW
result <- ParetoSorting(input)
result
# dominated count
dominated_count <- length(which(result == 1))
dominated_count
# not dominated count
notdominated_count <- length(which(result == 0))
notdominated_count
# function to create list stating string "dominated" or "pareto-efficient"
d_function <- function(list_input) {
result_list <- c()
for (i in 1:length(list_input)) {
if (list_input[i] == 1) {
name <- "Dominated"
} else {
name <- "Non-dominated"
}
result_list <- c(result_list, name)
}
return(result_list)
}
domination_list <- d_function(result)
domination_list
mydata$Dominance <- domination_list
# Then, we give a different colour to the points depending on the value in the column "Dominance"
a_plot2 <- ggplot(data=mydata, mapping = aes(x=Horsepower, y=Cost)) +
geom_point(aes(color=Dominance)) +
labs(title = "Activity 1a Plot 2: Horsepower vs Cost", x = "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot2
# How to visualize the third objective?
#
# We can represent the third objective (Fuel-efficiency) with a size or color. -- FILL IN THE LINES BELOW
# fuel efficiency by size
a_plot3 <- ggplot(data = mydata,
mapping = aes(x = Horsepower, y = Cost, size = Fuel.efficiency)) +
geom_point() + # Note that we removed "size = 3"
coord_cartesian(xlim=c(0.2,0.8), ylim=c(0,0.2)) +
labs(title = "Activity 1a Plot 3: Horsepower vs Cost", x= "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot3
# fuel efficiency by colour
a_plot4 <- ggplot(data = mydata,
mapping = aes(x = Horsepower, y = Cost, colour = Fuel.efficiency)) +
geom_point(size = 3) +
coord_cartesian(xlim=c(0.2,0.8), ylim=c(0,0.2)) +
labs(title = "Activity 1a Plot 4: Horsepower vs Cost", x= "Horsepower", y="Cost", caption="EngineDesign.csv")
a_plot4
#
# We could also use a 3D plot, for which we need the rgl package
a_plot5 <- plot3d(mydata$Horsepower, mydata$Cost, mydata$Fuel.efficiency, type="s",
size=1, lit=TRUE, main = "Horsepower Vs Cost Vs Fuel-efficiency",sub="3-D Plot")
rgl.postscript("1a Plot5.pdf", fmt = "pdf")
# Now, we can determine which solutions are Pareto-efficient. First, we use the source() function to load ParetoSorting.R
source("ParetoSorting_adv.R")
# Let's double-check the input (output) required (returned) by the function ParetoSorting.R
ParetoSorting_adv
# Prepare the input in the right format
input_adv <- matrix(c(mydata$Horsepower,mydata$Cost*(-1),mydata$Fuel.efficiency),nrow=43,ncol=3)
# Run the function -- FILL IN THE LINE BELOW
result_adv <- ParetoSorting_adv(input_adv, "MAX")
result_adv
# dominated count
dominated_count_adv <- length(which(result_adv == 1))
dominated_count_adv
